#pragma once
/*
interprocess_semaphore.h

Header-only, single file. Platform conditionals are **constrained**:
- One #if ladder selects Windows vs POSIX.
- On POSIX, a single #if ladder selects Linux vs Darwin; all other code is #if-free.

OVERVIEW
- Cross-platform semaphore with a 32-bit counter.
- POSIX uses a wait-on-address shim; Windows uses a named kernel semaphore.
- Single monotonic deadline timeline (ns). No fairness guarantee.

SUPPORTED OS (intentional; no fallbacks)
- Linux (futex), macOS 14.4+ (<os/sync_wait_on_address.h>), Windows 8+ (named kernel semaphore).
- Platform notes:
  * macOS: wake-all is used; may over-wake. If Apple adds wake-one/wake-N, prefer bounded waking.
  * POSIX wait(): implemented via a very large relative wait on a monotonic clock; effectively "infinite".
  * Windows try_wait(): returns false when no token is available and does not set errno; timed waits set errno=ETIMEDOUT.

INTERPROCESS SEMANTICS
- POSIX: the 32-bit wait word must be in shared memory (e.g., mmap MAP_SHARED).
- Windows: HANDLEs are per-process. Use the same explicit name in each process or place the object in shared memory; a lazy per-process open attaches to the embedded name.

API
  interprocess_semaphore(unsigned int initial = 0)
  interprocess_semaphore(unsigned int initial, const wchar_t* name, uint32_t max_count = 0x7fffffff)
  bool try_wait(); void wait(); bool timed_wait(...); bool try_wait_for(...); void post();
  void release_local_handle() (no-op on current backends)

NOTES
- Windows: max_count applies at creation; opening an existing named semaphore cannot change its kernel max.
- Instances are non-movable to avoid corrupting the POSIX shared counter. Copy is deleted as well.

ERROR SEMANTICS
- wait(): loops forever until acquired; never returns false in normal use
- Timed waits: false on timeout or error. Check errno; ETIMEDOUT means timeout.
- POSIX post: post(0) is a no-op; overflow sets errno=EOVERFLOW and does not wake.
- Windows post: post(0) is a no-op.

BUILD REQUIREMENTS
- The wait word is a naturally aligned 32-bit word accessed atomically (lock-free required).
*/

#include <atomic>
#include <cstdint>
#include <chrono>
#include <cerrno>
#include <climits>
#include <cwchar>
#include <limits>

// Platform headers MUST be included BEFORE opening namespaces to avoid polluting them
#if defined(_WIN32)
  #define NOMINMAX  // Prevent Windows.h from defining min/max macros
  #include <windows.h>
  #include <synchapi.h>
  #include <mutex>
  #include <unordered_map>
  #include <string>
#else
  #include <time.h>
  // Single selection ladder for sub-platform specifics
  #if defined(__APPLE__) && defined(__MACH__) && defined(__has_include) && __has_include(<os/sync_wait_on_address.h>)  
    #define SINTRA_BACKEND_DARWIN 1
    #include <os/clock.h>
    #include <os/sync_wait_on_address.h>
  #elif defined(__linux__)
    #define SINTRA_BACKEND_LINUX 1
    #include <sys/syscall.h>
    #include <linux/futex.h>
    #include <unistd.h>
  #else
    #define SINTRA_BACKEND_UNSUPPORTED 1
  #endif
#endif

namespace sintra { namespace detail {

static_assert(std::atomic<uint32_t>::is_always_lock_free, "requires lock-free 32-bit atomic");

// ========================== Backend (single #if ladder) ==========================
struct ips_backend
{
    void   init_default(uint32_t initial) noexcept;
    void   init_named(uint32_t initial, const wchar_t* name, uint32_t max_count) noexcept;
    bool   try_wait() noexcept;
    bool   wait() noexcept;
    bool   try_wait_for(std::chrono::nanoseconds d) noexcept;
    void   post(uint32_t n) noexcept;
    void   destroy() noexcept;

    alignas(8) unsigned char storage[256]{}; // zero-initialized
};

// ----------------------------- Windows backend -----------------------------
#if defined(_WIN32)

  #if defined(_MSC_VER)
    #define bounded_swprintf(buf, cch, fmt, x)  _snwprintf_s(buf, cch, _TRUNCATE, fmt, x)
    #define bounded_swprintf2(buf, cch, fmt, s) _snwprintf_s(buf, cch, _TRUNCATE, fmt, s)
    #define backoff_yield() YieldProcessor()
  #else
    #define bounded_swprintf(buf, cch, fmt, x)  swprintf(buf, cch, fmt, x)
    #define bounded_swprintf2(buf, cch, fmt, s) swprintf(buf, cch, fmt, s)
    #if defined(__x86_64__) || defined(__i386__)
      #define backoff_yield() __asm__ __volatile__("pause")
    #elif defined(__aarch64__) || defined(__arm__)
      #define backoff_yield() __asm__ __volatile__("yield")
    #else
      #define backoff_yield() ((void)0)  // No-op on other archs
    #endif
  #endif


struct ips_backend_win_state
{
    // 0=uninit, 1=initializing, 2=ready
    volatile long init_flag = 0;
    uint32_t initial = 0;
    uint32_t max = 0x7fffffff;
    bool     was_autogenerated = false;
    wchar_t  name[64] = {0};
};
static_assert(sizeof(ips_backend_win_state) <= sizeof(((ips_backend*)0)->storage),
              "ips_backend::storage too small for Windows backend");
static_assert(alignof(ips_backend) >= alignof(ips_backend_win_state),
              "backend align too small");

static ips_backend_win_state& W(ips_backend& b) noexcept
{
    return *reinterpret_cast<ips_backend_win_state*>(b.storage);
}


struct ips_win_handle_cache
{
    std::mutex m;
    std::unordered_map<std::wstring, HANDLE> map;
    ~ips_win_handle_cache()
    {
        for (auto& kv : map) {
            if (kv.second) {
                CloseHandle(kv.second);
            }
        }
    }
};

static inline ips_win_handle_cache& ips_win_handles()
{
    static ips_win_handle_cache cache;
    return cache;
}

static bool ips_win_copy_name(ips_backend& b, const wchar_t* s) noexcept
{
    auto& st = W(b);
    if (!s || !s[0]) {
        st.name[0] = L'\0'; return true;
    }
    // Do not modify st.name unless it fits
    size_t len = 0;
    while (s[len] != L'\0') {
        ++len;
    }
    if (len >= 63) {
        errno = ENAMETOOLONG; return false;
    }
    for (size_t i=0; i<=len; ++i) {
        st.name[i] = s[i];
    }
    return true;
}


// Return a per-process HANDLE for the named semaphore, creating/opening if needed.
static HANDLE ips_win_local_handle(ips_backend& b) noexcept
{
    auto& st = W(b);
    if (st.name[0] == L'\0') {
        errno = EINVAL; return nullptr;
    }

    auto& cache = ips_win_handles();
    std::lock_guard<std::mutex> lock(cache.m);

    std::wstring key(st.name);
    auto it = cache.map.find(key);
    if (it != cache.map.end() && it->second) {
        return it->second;
    }
    HANDLE h = CreateSemaphoreW(nullptr, (LONG)st.initial, (LONG)st.max, st.name);
    if (!h) {
        DWORD last = GetLastError();
        // If Global namespace access denied and we auto-generated, try Local
        if (last == ERROR_ACCESS_DENIED && st.was_autogenerated &&
            wcsncmp(st.name, L"Global\\", 7) == 0)
        {
            wchar_t local[64];
            bounded_swprintf2(local, 64, L"Local\\%s", st.name + 7);
            (void)ips_win_copy_name(b, local);
            key.assign(st.name);
            h = CreateSemaphoreW(nullptr, (LONG)st.initial, (LONG)st.max, st.name);
        }
        // If still failed, try opening existing
        if (!h) {
            h = OpenSemaphoreW(SYNCHRONIZE | SEMAPHORE_MODIFY_STATE, FALSE, st.name);
        }
    }
    if (h) {
        cache.map.emplace(std::move(key), h);
    }
    return h;
}



static void ips_win_ensure_ready(ips_backend& b) noexcept
{
    auto& st = W(b);
    if (st.init_flag == 2) {
        return;
    }
    if (InterlockedCompareExchange(&st.init_flag, 1, 0) == 0) {
        // We are the initializer
        if (st.name[0] == L'\0') {
            if (st.was_autogenerated) {
                FILETIME ft; GetSystemTimeAsFileTime(&ft);
                unsigned pid = GetCurrentProcessId();
                unsigned tid = GetCurrentThreadId();
                uintptr_t self = (uintptr_t)&b;
                unsigned long long x =
                    ((unsigned long long)ft.dwLowDateTime) ^
                    ((unsigned long long)ft.dwHighDateTime<<32) ^
                    ((unsigned long long)pid<<13) ^
                    ((unsigned long long)tid<<7) ^
                    ((unsigned long long)self);
                wchar_t buf[64];
                bounded_swprintf(buf, 64, L"Global\\SintraSem_%016llX", x);
                ips_win_copy_name(b, buf);
            }
            else {
                errno = EINVAL;
            }
        }
        MemoryBarrier();
        InterlockedExchange(&st.init_flag, 2);
    }
    else {
        // Wait until published (state==2)
        unsigned spins = 0;
        while (st.init_flag != 2) {
            backoff_yield();
            if ((++spins & 0x3FFF) == 0) {
                Sleep(0);
            }
        }
    }
}

static void ips_win_create_or_open(ips_backend& b) noexcept
{
    // Ensure there is a per-process handle available for this name.
    (void)ips_win_local_handle(b);

}


// 1) Make sure default ctor actually autogenerates a name
inline void ips_backend::init_default(uint32_t initial) noexcept
{
    auto& st = W(*this);
    st.initial = initial;
    st.max = 0x7fffffff;
    if (initial > st.max)  {
        errno = EINVAL;
        InterlockedExchange(&st.init_flag, 2);
        return;
    }
    st.was_autogenerated = true;
    ips_win_ensure_ready(*this);   // <-- generate Global\SintraSem_â€¦ name now
}

// 2) If name is absent, treat as autogenerated and generate it now
inline void ips_backend::init_named(
    uint32_t initial, const wchar_t* name, uint32_t max_count) noexcept
{
    auto& st = W(*this);
    st.initial = initial;
    st.max = max_count;
    if (initial > max_count) {
        errno = EINVAL;
        InterlockedExchange(&st.init_flag, 2);
        return;
    }

    if (name && name[0] != L'\0') {
        st.was_autogenerated = false;
        if (!ips_win_copy_name(*this, name)) {
            InterlockedExchange(&st.init_flag, 2);
            return;
        }
    }
    else {
        st.was_autogenerated = true;
        ips_win_ensure_ready(*this);   // <-- generate a name
    }
}

// 3) Ensure name exists before opening/creating a handle
static void ips_win_ensure_handle(ips_backend& b) noexcept
{
    ips_win_ensure_ready(b);           // <-- guarantees st.name is set if autogen was intended
    (void)ips_win_local_handle(b);
}

// 4) Avoid double lookup in try_wait (similar in wait/try_wait_for)
inline bool ips_backend::try_wait() noexcept
{
    ips_win_ensure_handle(*this);
    HANDLE h = ips_win_local_handle(*this);
    if (!h) {
        errno = EINVAL;
        return false;
    }
    return WaitForSingleObject(h, 0) == WAIT_OBJECT_0;
}


inline bool ips_backend::wait() noexcept
{
    ips_win_ensure_handle(*this);
    HANDLE h = ips_win_local_handle(*this);
    if (!h) {
        errno = EINVAL;
        return false;
    }
    DWORD rc = WaitForSingleObject(h, INFINITE);
    if (rc == WAIT_OBJECT_0) {
        return true;
    }
    errno = EINVAL;
    return false;
}

inline bool ips_backend::try_wait_for(std::chrono::nanoseconds d) noexcept
{
    ips_win_ensure_handle(*this);
    HANDLE h = ips_win_local_handle(*this);
    if (!h) {
        errno = EINVAL;
        return false;
    }
    uint64_t add = d.count() <= 0 ? 0ULL : (uint64_t)d.count();
    DWORD ms;
    if (add/1000000ULL >= 0xFFFFFFFFULL) {
        ms = INFINITE - 1;
    }
    else {
        ms = (DWORD)(add/1000000ULL);
        if (ms == 0 && add > 0) {
            ms = 1;
        }
    }

    DWORD rc = WaitForSingleObject(h, ms);
    if (rc == WAIT_OBJECT_0) {
        return true;
    }
    if (rc == WAIT_TIMEOUT) {
        errno = ETIMEDOUT; return false;
    }
    errno = EINVAL;
    return false;
}

inline void ips_backend::post(uint32_t n) noexcept
{
    if (n == 0) return;
    ips_win_ensure_handle(*this);
    HANDLE h = ips_win_local_handle(*this);
    if (!h) {
        errno = EINVAL; return;
    }
    if (n > (uint32_t)LONG_MAX) {
        errno = EOVERFLOW; return;
    }
    if (!ReleaseSemaphore(h, (LONG)n, nullptr)) {
        DWORD e = GetLastError();
        errno = (e == ERROR_TOO_MANY_POSTS) ? EOVERFLOW : EINVAL;
    }
}

inline void ips_backend::destroy() noexcept
{
    // Per-process cached handles are kept for the life of the process.
}

#else // ----------------------------- POSIX backend -----------------------------



static inline uint64_t now_ns() noexcept
{
#if SINTRA_BACKEND_DARWIN
    return clock_gettime_nsec_np(CLOCK_MONOTONIC);
#else
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)ts.tv_sec * 1000000000ULL + (uint64_t)ts.tv_nsec;
#endif
}

#if SINTRA_BACKEND_LINUX
static inline void ns_to_timespec(uint64_t ns, struct timespec& ts)
{
    uint64_t sec = ns / 1000000000ULL;
    uint64_t tmax = (uint64_t)std::numeric_limits<time_t>::max();
    if (sec > tmax) sec = tmax;
    ts.tv_sec  = (time_t)sec;
    ts.tv_nsec = (long)(ns % 1000000000ULL);
}

static inline int futex_wait(int* addr, int val, const struct timespec* rel)
{
    return (int)syscall(SYS_futex, addr, FUTEX_WAIT, val, rel, nullptr, 0);
}

static inline int futex_wake(int* addr, int n)
{
    return (int)syscall(SYS_futex, addr, FUTEX_WAKE, n, nullptr, nullptr, 0);
}
#endif

// Unified POSIX helpers (no further #ifs elsewhere)
static inline int posix_wait_equal_until(
    uint32_t* addr, uint32_t expected, uint64_t deadline) noexcept
{
#if SINTRA_BACKEND_DARWIN
    const uint32_t flags = OS_SYNC_WAIT_ON_ADDRESS_SHARED;
    for (;;) {
        int rc = os_sync_wait_on_address_with_deadline(
		    (void*)addr, (uint64_t)expected, 4, flags, OS_CLOCK_MONOTONIC, deadline);
        if (rc >= 0)                           return  0;
        if (errno == ETIMEDOUT)                return -1;
        if (errno == EINTR || errno == EAGAIN) continue;
        return -1;
    }
#elif SINTRA_BACKEND_LINUX
    for (;;) {
        const uint64_t now = now_ns();
        if (now >= deadline) {
            errno = ETIMEDOUT; return -1;
        }
        struct timespec ts;
        ns_to_timespec(deadline - now, ts);
        int rc = futex_wait((int*)addr, (int)expected, &ts);
        if (rc == 0)                           return  0; // value changed or spuriously woke; caller rechecks
        if (errno == ETIMEDOUT)                return -1;
        if (errno == EINTR || errno == EAGAIN) continue;
        return -1;
    }
#else
    (void)addr; (void)expected; (void)deadline;
    errno = ENOTSUP;
    return -1;
#endif
}

static inline void posix_wake_some(uint32_t* addr, int n) noexcept
{
#if SINTRA_BACKEND_LINUX
    if (n < 0)       n = 0;
    if (n > INT_MAX) n = INT_MAX;
    (void)futex_wake((int*)addr, n);
#elif SINTRA_BACKEND_DARWIN
    (void)n;  // Darwin doesn't have wake-N, always use wake-all
    (void)os_sync_wake_by_address_all((void*)addr, 4, OS_SYNC_WAKE_BY_ADDRESS_SHARED);
#else
    (void)addr; (void)n;
#endif
}


struct ips_backend_posix_state
{
    std::atomic<uint32_t> count{0};
    uint32_t max = 0x7fffffff;
};

static_assert(sizeof(ips_backend_posix_state) <= sizeof(((ips_backend*)0)->storage),
              "ips_backend::storage too small for POSIX backend");
static_assert(alignof(ips_backend) >= alignof(ips_backend_posix_state),
              "backend align too small");

static ips_backend_posix_state& P(ips_backend& b) noexcept
{
    return *reinterpret_cast<ips_backend_posix_state*>(b.storage);
}

inline void ips_backend::init_default(uint32_t initial) noexcept
{
    auto& st = P(*this);
    st.max = 0x7fffffff;
    if (initial > st.max) {
        errno = EINVAL;
        st.max = 0;
        st.count = 0;
        return;
    }
    st.count = initial;
}

inline void ips_backend::init_named(
    uint32_t initial, const wchar_t*, uint32_t max_count) noexcept
{
    // Name unused on POSIX (interprocess via shared memory placement).
    auto& st = P(*this);
    st.max = max_count;
    if (initial > max_count) {
        errno = EINVAL;
        st.max = 0;
        st.count = 0;
        return;
    }
    st.count = initial;
}

inline bool ips_backend::try_wait() noexcept
{
    std::atomic<uint32_t>& c = P(*this).count;
    uint32_t v = c.load(std::memory_order_acquire);
    while (v != 0) {
        if (c.compare_exchange_weak(v, v-1, std::memory_order_acq_rel, std::memory_order_acquire)) {
            return true;
        }
    }
    return false;
}

inline bool ips_backend::wait() noexcept
{
    if (try_wait()) return true;
    // Use very large timeout for "infinite" wait
    return try_wait_for(std::chrono::nanoseconds(1ULL<<60));
}

inline bool ips_backend::try_wait_for(std::chrono::nanoseconds d) noexcept
{
    std::atomic<uint32_t>& c = P(*this).count;
    if (try_wait()) return true;

    const uint64_t add = d.count() <= 0 ? 0ULL : (uint64_t)d.count();
    const uint64_t deadline = now_ns() + add;

    for (;;) {
        uint32_t cur = c.load(std::memory_order_acquire);
        if (cur != 0) {
            if (c.compare_exchange_weak(cur, cur-1, std::memory_order_acq_rel, std::memory_order_relaxed))
                return true;
            continue;
        }
        if (now_ns() >= deadline) {
            errno = ETIMEDOUT;
            return false;
        }
        if (posix_wait_equal_until(reinterpret_cast<uint32_t*>(&P(*this).count), 0u, deadline) == -1) {
            if (errno == ETIMEDOUT) {
                return false;
            }
            if (errno == ENOTSUP) {
                struct timespec ts{0, 1'000'000}; nanosleep(&ts, nullptr);
            }
            // other errors treated as spurious; loop and recheck
        }
    }
}

inline void ips_backend::post(uint32_t n) noexcept
{
    if (n == 0) return;

    std::atomic<uint32_t>& c = P(*this).count;
    uint32_t v = c.load(std::memory_order_relaxed);
    const uint32_t maxv = P(*this).max;

    for (;;) {
        if (n > maxv - v) {
            errno = EOVERFLOW;
            return;
        }
        if (c.compare_exchange_weak(v, v + n, std::memory_order_release, std::memory_order_relaxed)) {
            break;
        }
    }

    posix_wake_some(reinterpret_cast<uint32_t*>(&P(*this).count), (int)n);
}

inline void ips_backend::destroy() noexcept
{
    // Nothing to do for POSIX
}

#endif // end backend selection

// ========================== Public class (no #ifs below) ==========================
class interprocess_semaphore
{
public:
    // Constructor matching current API (unsigned int for compatibility)
    explicit interprocess_semaphore(unsigned int initial = 0) noexcept
    {
        m_impl.init_default(static_cast<uint32_t>(initial));
    }

    interprocess_semaphore(unsigned int initial, const wchar_t* name, uint32_t max_count = 0x7fffffff) noexcept
    {
        m_impl.init_named(static_cast<uint32_t>(initial), name, max_count);
    }

    ~interprocess_semaphore()
    {
        m_impl.destroy();
    }

    // Non-copyable and non-movable (critical for shared memory correctness)
    interprocess_semaphore(const interprocess_semaphore&) = delete;
    interprocess_semaphore& operator=(const interprocess_semaphore&) = delete;
    interprocess_semaphore(interprocess_semaphore&&) = delete;
    interprocess_semaphore& operator=(interprocess_semaphore&&) = delete;

    // API compatibility: void wait() (loops forever until acquired)
    void wait() noexcept
    {
        while (!m_impl.wait()) { if (errno == EINVAL) break; }
    }

    // API compatibility: bool try_wait()
    bool try_wait() noexcept
    {
        return m_impl.try_wait();
    }

    // API compatibility: void post() (posts single token)
    void post() noexcept
    {
        m_impl.post(1);
    }

    // API compatibility: templated timed_wait (requires steady clock)
    template <typename Clock, typename Duration>
    bool timed_wait(const std::chrono::time_point<Clock, Duration>& abs_time) noexcept
    {
        static_assert(Clock::is_steady, "timed_wait requires a steady clock to avoid wall-clock jumps");

        auto now_chrono = Clock::now();
        if (abs_time <= now_chrono) {
            return false; // Deadline already passed
        }

        auto delta = abs_time - now_chrono;
        auto delta_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(delta);

        return m_impl.try_wait_for(delta_ns);
    }

    // API compatibility: try_wait_for with duration
    bool try_wait_for(std::chrono::nanoseconds rel_timeout) noexcept
    {
        return m_impl.try_wait_for(rel_timeout);
    }

    // API compatibility: no-op on current backends
    void release_local_handle() noexcept
    {
        // No-op (Windows named semaphores handle this internally)
    }

private:
    ips_backend m_impl;
};

}} // namespace sintra::detail
